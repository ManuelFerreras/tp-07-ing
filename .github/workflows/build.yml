name: CI
on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  build_test_front:
    name: Frontend - Tests & Coverage
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Install & test (coverage)
        working-directory: front
        run: |
          npm ci
          npm run test:ci
      - name: Upload lcov
        uses: actions/upload-artifact@v4
        with:
          name: front-coverage
          path: front/coverage/lcov.info

  build_test_back:
    name: Backend - Tests & Coverage Gate
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: "1.22"
      - name: Coverage gate (>=70%)
        working-directory: back
        run: |
          make check-cover
          go install github.com/t-yuki/gocover-cobertura@latest
          gocover-cobertura < cover.out > cobertura.xml
      - name: Upload Go coverage
        uses: actions/upload-artifact@v4
        with:
          name: back-coverage
          path: |
            back/cover.out
            back/cobertura.xml

  sonar:
    name: SonarCloud - Scan & Quality Gate
    runs-on: ubuntu-latest
    needs: [build_test_front, build_test_back]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Download front coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: front-coverage
          path: front/coverage
      - name: Download back coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: back-coverage
          path: back
      - uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"
      # Reuse the scanner action created by Sonar setup (works with SonarCloud when host URL is set)
      - name: Sonar Scan
        uses: SonarSource/sonarqube-scan-action@v6
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io
          SONAR_ORG: ${{ vars.SONAR_ORG }}
          SONAR_PROJECT_KEY: ${{ vars.SONAR_PROJECT_KEY }}
          SONAR_PROJECT_NAME: ${{ vars.SONAR_PROJECT_NAME }}
      - name: Wait for Sonar Quality Gate
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          REPORT=$(find . -type f -path "*/.scannerwork/report-task.txt" | head -n1)
          if [ -z "$REPORT" ]; then echo "report-task.txt not found"; exit 1; fi
          CE_TASK_ID=$(grep ceTaskId "$REPORT" | cut -d= -f2)
          for i in {1..30}; do
            STATUS=$(curl -s -u "${SONAR_TOKEN}:" "https://sonarcloud.io/api/ce/task?id=${CE_TASK_ID}" | jq -r '.task.status')
            if [ "$STATUS" = "SUCCESS" ]; then break; fi
            if [ "$STATUS" = "FAILED" ]; then echo "Sonar CE task failed"; exit 1; fi
            sleep 5
          done
          ANALYSIS_ID=$(curl -s -u "${SONAR_TOKEN}:" "https://sonarcloud.io/api/ce/task?id=${CE_TASK_ID}" | jq -r '.task.analysisId')
          QG=$(curl -s -u "${SONAR_TOKEN}:" "https://sonarcloud.io/api/qualitygates/project_status?analysisId=${ANALYSIS_ID}" | jq -r '.projectStatus.status')
          echo "Quality Gate: $QG"
          test "$QG" = "OK"

  e2e:
    name: E2E - Cypress
    runs-on: ubuntu-latest
    needs: [sonar]
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: "1.22"
      - name: Start backend
        working-directory: back
        run: |
          nohup bash -c 'DB_DSN=./employees.db go run . > ../back_server.log 2>&1' &
          sleep 2
      - uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Build & start frontend
        working-directory: front
        run: |
          npm ci
          npm run build
          nohup bash -c 'NEXT_PUBLIC_API_URL=http://localhost:8080 npm run start > ../front_server.log 2>&1' &
          sleep 3
      - name: Cypress run
        working-directory: e2e
        env:
          FRONTEND_URL: http://localhost:3000
        run: |
          npm ci
          npx cypress run --headless
      - name: Upload Cypress artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-artifacts
          path: |
            e2e/cypress/results/*.xml
            e2e/cypress/videos/**
            e2e/cypress/screenshots/**

  docker_push:
    name: Docker - Build & Push to GHCR
    runs-on: ubuntu-latest
    needs: [sonar]
    permissions:
      contents: read
      packages: write
    env:
      REGISTRY: ghcr.io
      OWNER: ${{ github.repository_owner }}
      REPO: ${{ github.event.repository.name }}
    steps:
      - uses: actions/checkout@v4
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Compute tags
        id: meta
        run: |
          OWNER_LC=$(echo "${OWNER}" | tr '[:upper:]' '[:lower:]')
          IMAGE_BACK=${REGISTRY}/${OWNER_LC}/${REPO}-back
          IMAGE_FRONT=${REGISTRY}/${OWNER_LC}/${REPO}-front
          SHA=${{ github.sha }}
          echo "image_back=${IMAGE_BACK}" >> $GITHUB_OUTPUT
          echo "image_front=${IMAGE_FRONT}" >> $GITHUB_OUTPUT
          echo "tag_sha=${SHA}" >> $GITHUB_OUTPUT
      - name: Build & push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./back
          file: ./back/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.image_back }}:${{ steps.meta.outputs.tag_sha }}
            ${{ steps.meta.outputs.image_back }}:latest
      - name: Build & push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./front
          file: ./front/Dockerfile
          push: true
          build-args: |
            NEXT_PUBLIC_API_URL=http://localhost:8080
          tags: |
            ${{ steps.meta.outputs.image_front }}:${{ steps.meta.outputs.tag_sha }}
            ${{ steps.meta.outputs.image_front }}:latest
